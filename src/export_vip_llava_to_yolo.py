#!/usr/bin/env python3
"""Convert ViP-LLaVA annotation outputs to YOLO format."""
from __future__ import annotations

import argparse
import json
import logging
from pathlib import Path
from typing import Dict, List, Tuple

from PIL import Image

from icon_box_utils import bbox_to_yolo, load_icon_boxes


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Merge ViP-LLaVA overlay annotations with bounding boxes and export YOLO labels."
    )
    parser.add_argument(
        "--annotations-dir",
        type=Path,
        required=True,
        help="Directory containing *_vip_llava.json files generated by annotate_icons_vip_llava.py.",
    )
    parser.add_argument(
        "--boxes-dir",
        type=Path,
        required=True,
        help="Directory containing bounding box JSON files (one per image).",
    )
    parser.add_argument(
        "--images-dir",
        type=Path,
        required=True,
        help="Directory containing the original images referenced by the annotations.",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        required=True,
        help="Directory where YOLO *.txt files will be stored.",
    )
    parser.add_argument(
        "--boxes-suffix",
        default=".json",
        help="File extension for bounding box files (default: .json).",
    )
    parser.add_argument(
        "--classes-file",
        type=Path,
        default=None,
        help="Optional path to an existing classes.txt file. Defaults to output-dir/classes.txt.",
    )
    parser.add_argument(
        "--strict",
        action="store_true",
        help="Fail if an icon ID is missing from the bounding boxes. Otherwise skip with a warning.",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    logging.basicConfig(
        level=logging.INFO,
        format="%(levelname)s: %(message)s",
    )

    for directory in (args.annotations_dir, args.boxes_dir, args.images_dir):
        if not directory.exists():
            logging.error("Directory %s does not exist", directory)
            return 1

    output_dir = args.output_dir
    output_dir.mkdir(parents=True, exist_ok=True)

    classes_path = args.classes_file or (output_dir / "classes.txt")
    class_names = load_class_names(classes_path)
    class_index = {name: idx for idx, name in enumerate(class_names)}

    annotation_files = sorted(
        path for path in args.annotations_dir.iterdir() if path.suffix.lower() == ".json"
    )
    if not annotation_files:
        logging.error("No annotation JSON files found in %s", args.annotations_dir)
        return 1

    for annotation_path in annotation_files:
        payload = load_annotation(annotation_path)
        image_name = payload["image"]
        image_path = args.images_dir / image_name
        if not image_path.exists():
            logging.warning("Skipping %s because %s is missing", annotation_path.name, image_name)
            continue

        with Image.open(image_path) as pil_image:
            image_size = pil_image.size

        boxes_path = (args.boxes_dir / Path(image_name).stem).with_suffix(args.boxes_suffix)
        if not boxes_path.exists():
            logging.warning("Skipping %s because bounding boxes file %s is missing", image_name, boxes_path.name)
            continue

        boxes = load_icon_boxes(boxes_path, image_size)
        yolo_lines: List[str] = []

        for annotation in payload["annotations"]:
            icon_id = annotation["id"]
            label = annotation["name"]
            bbox = boxes.get(icon_id)
            if bbox is None:
                message = f"Icon {icon_id} from {annotation_path.name} missing in {boxes_path.name}"
                if args.strict:
                    raise RuntimeError(message)
                logging.warning(message)
                continue

            class_id = class_index.get(label)
            if class_id is None:
                class_id = len(class_names)
                class_names.append(label)
                class_index[label] = class_id

            cx, cy, bw, bh = bbox_to_yolo(bbox, image_size)
            yolo_lines.append(f"{class_id} {cx:.6f} {cy:.6f} {bw:.6f} {bh:.6f}")

        target = output_dir / f"{Path(image_name).stem}.txt"
        with target.open("w", encoding="utf-8") as handle:
            handle.write("\n".join(yolo_lines))

    save_class_names(classes_path, class_names)
    logging.info("Export complete. YOLO labels in %s", output_dir)
    logging.info("Class list written to %s", classes_path)
    return 0


def load_annotation(path: Path) -> Dict[str, object]:
    with path.open("r", encoding="utf-8") as handle:
        payload = json.load(handle)

    if "annotations" not in payload:
        raise ValueError(f"Annotation file {path} missing 'annotations' key")

    return payload


def load_class_names(path: Path) -> List[str]:
    if not path.exists():
        return []
    with path.open("r", encoding="utf-8") as handle:
        return [line.strip() for line in handle if line.strip()]


def save_class_names(path: Path, class_names: List[str]) -> None:
    with path.open("w", encoding="utf-8") as handle:
        handle.write("\n".join(class_names))


if __name__ == "__main__":
    raise SystemExit(main())
